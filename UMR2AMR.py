#!/usr/bin/env python3

# This library is under the 3-Clause BSD License
#
# Copyright (c) 2025,  Orange
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#
#    * Neither the name of Orange nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL ORANGE BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# SPDX-License-Identifier: BSD-3-Clause
# Software Name: MetAMoRphosED AMR-Editor
# Author: Johannes Heinecke

import os
import sys

import penman

import metamorphosed.umrdoc as umrdoc

# undo silencing of umrdoc
# import logging
# logging.getLogger('penman').setLevel(logging.INFO)


class UMR2AMR:
    def __init__(self, infile, outfile, first=0, last=0, filterid=None, doalignments=True, prefix=None, gen=True):
        udoc = umrdoc.UMRdoc(infile)

        ofp = open(outfile, "w")

        if gen:
            print("# generated by:", " ".join(sys.argv), file=ofp)
        for ct, sent in enumerate(udoc.sentences, 1):
            if ct < first:
                continue
            if last != 0 and ct > last:
                continue

            if len(sent.amr.split("\n")) == 1 and "umr-empty" in sent.amr:
                print("Ignore empty sentence", sent.id, file=sys.stderr)
                continue

            try:
                pg = penman.decode(sent.amr)
                # we need this since penman does not stop at warnings:
                # things like
                #  (t / 12
                #       :00
                #        :name (n / name
                #                :op1 "Noon")))
                # output a "missing target" in the logger, but adds a triple with a None object
                for s, p, o in pg.triples:
                    if o is None:
                        raise Exception("bad triple <%s %s %s>" % (s, p, o))
            except Exception as e:
                print("ERROR: Invalid penman format in %s: %s" % (sent.id, e), file=sys.stderr)
                continue

            if "sent_id" in sent.meta:
                if filterid:
                    if not filterid.match(sent.meta["sent_id"]):
                        continue
                if prefix:
                    print("# ::id", prefix + sent.meta["sent_id"], file=ofp)
                else:
                    print("# ::id", sent.meta["sent_id"], file=ofp)
            else:
                if filterid:
                    if not filterid.match(sent.id):
                        continue
                if prefix:
                    print("# ::id", prefix + sent.id, file=ofp)
                else:
                    print("# ::id", sent.id, file=ofp)
            if sent.text:
                print("# ::snt", sent.text, file=ofp)
            elif sent.words:
                print("# ::snt", " ".join(sent.words), file=ofp)
            if sent.words:
                print("# ::tok", " ".join(sent.words), file=ofp)
            else:
                print("ERROR: No sentence in " + sent.id, file=sys.stderr)

            #newtriples = []
            # pg = penman.decode(sent.amr)

            if doalignments:
                alignment_indices = {} # triple: [index]
                ralignment_indices = {} # triple: [index]
                for tr in pg.instances():
                    if tr[0] in sent.alignments:
                        for al in sorted(sent.alignments[tr[0]]):
                            if al[0] > 0:
                                #pg.epidata[(tr[0], tr[1], tr[2])].append(penman.surface.Alignment((al[0],), "e."))
                                if (tr[0], tr[1], tr[2]) not in alignment_indices:
                                    alignment_indices[(tr[0], tr[1], tr[2])] = set()
                                alignment_indices[(tr[0], tr[1], tr[2])].add(al[0] - 1)
                                if al[1] != al[0]:
                                    alignment_indices[(tr[0], tr[1], tr[2])].add(al[1] - 1)
                for tr in pg.edges():
                    key = "%s#%s#%s#RA" % (tr[0], tr[2], tr[1][1:])
                    if key in sent.ralignments:
                        for al in sent.ralignments[key]:
                            if al[0] > 0:
                                #pg.epidata[(tr[0], tr[1], tr[2])].append(penman.surface.RoleAlignment((al[0],), "e."))
                                if (tr[0], tr[1], tr[2]) not in ralignment_indices:
                                    ralignment_indices[(tr[0], tr[1], tr[2])] = set()
                                ralignment_indices[(tr[0], tr[1], tr[2])].add(al[0] - 1)

                for tr in pg.attributes():
                    key = "%s#%s#%s#LA" % (tr[0], tr[1][1:], tr[2])
                    if key in sent.lalignments:
                        for al in sent.lalignments[key]:
                            if al[0] > 0:
                                #pg.epidata[(tr[0], tr[1], tr[2])].append(penman.surface.Alignment((al[0],), "e."))
                                if (tr[0], tr[1], tr[2]) not in alignment_indices:
                                    alignment_indices[(tr[0], tr[1], tr[2])] = set()
                                alignment_indices[(tr[0], tr[1], tr[2])].add(al[0] - 1)
                for k, v in alignment_indices.items():
                    pg.epidata[k].append(penman.surface.Alignment(sorted(v), "e."))
                for k, v in ralignment_indices.items():
                    pg.epidata[k].append(penman.surface.RoleAlignment(sorted(v), "e."))

            pt = penman.configure(pg)
            # {prefix} does not work with data from UMR since there are "concepts" with diacritics and digits in first pos
            # pt.reset_variables(fmt="{prefix}{j}") # TODO keeps accents on variable idconcepts starts with an accented letter
            pt.reset_variables(fmt="v{j}") # TODO keeps accents on variable idconcepts starts with an accented letter
            print(penman.format(pt, indent=4), file=ofp)
            print(file=ofp)


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser("UMR2AMR transformation")

    parser.add_argument("--infile", "-i", required=True, help="UMR input file to read")
    parser.add_argument("--outfile", "-o", required=True, help="AMR output file")
    parser.add_argument("--first", "-f", default=0, type=int, help="start at sentence number <first>")
    parser.add_argument("--last", "-l", default=0, type=int, help="stop after sentence number <last>")
    parser.add_argument("--filterid", "-F", help="ignore sentences which sentence id does not mutch given regex")
    parser.add_argument("--noalignments", action='store_false', default=True, help='do not output UMR aligments')
    parser.add_argument("--id_prefix", help="prefix sentence ids with given string")

    if len(sys.argv) < 2:
        parser.print_help()
    else:
        args = parser.parse_args()
        a2u = UMR2AMR(args.infile, args.outfile, args.first, args.last, args.filterid, doalignments=args.noalignments, prefix=args.id_prefix)
