#!/usr/bin/env python3

# This library is under the 3-Clause BSD License
#
# Copyright (c) 2025,  Orange
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#
#    * Neither the name of Orange nor the
#      names of its contributors may be used to endorse or promote products
#      derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL ORANGE BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
# SPDX-License-Identifier: BSD-3-Clause
# Software Name: MetAMoRphosED AMR-Editor
# Author: Johannes Heinecke

import os
import sys

import penman

import metamorphosed.umrdoc as umrdoc


class UMR2AMR:
    def __init__(self, infile, outfile, first=0, last=0, filterid=None, gen=True):
        udoc = umrdoc.UMRdoc(infile)

        ofp = open(outfile, "w")

        if gen:
            print("# generated by:", " ".join(sys.argv), file=ofp)
        for ct, sent in enumerate(udoc.sentences, 1):
            if ct < first:
                continue
            if last != 0 and ct > last:
                continue

            if "sent_id" in sent.meta:
                if filterid:
                    if not filterid.match(sent.meta["sent_id"]):
                        continue
                print("# ::id", sent.meta["sent_id"], file=ofp)
            else:
                if filterid:
                    if not filterid.match(sent.id):
                        continue
                print("# ::id", sent.id, file=ofp)
            if sent.text:
                print("# ::snt", sent.text, file=ofp)
            elif sent.words:
                print("# ::snt", " ".join(sent.words), file=ofp)
            if sent.words:
                print("# ::tok", " ".join(sent.words), file=ofp)
            else:
                print("ERROR: No sentence in " + sent.id, file=sys.stderr)

            #newtriples = []
            pg = penman.decode(sent.amr)
            for tr in pg.instances():
                if tr[0] in sent.alignments:
                    for al in sent.alignments[tr[0]]:
                        if al[0] > 0:
                            pg.epidata[(tr[0], tr[1], tr[2])].append(penman.surface.Alignment((al[0],), "e."))

            pt = penman.configure(pg)
            pt.reset_variables(fmt="{prefix}{j}")
            print(penman.format(pt, indent=4), file=ofp)
            print(file=ofp)


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser("UMR2AMR transformation")

    parser.add_argument("--infile", "-i", required=True, help="UMR input file to read")
    parser.add_argument("--outfile", "-o", required=True, help="AMR output file")
    parser.add_argument("--first", "-f", default=0, type=int, help="start at sentence number <first>")
    parser.add_argument("--last", "-l", default=0, type=int, help="stop after sentence number <last>")
    parser.add_argument("--filterid", "-F", help="ignore sentences which sentence id does not mutch given regex")

    if len(sys.argv) < 2:
        parser.print_help()
    else:
        args = parser.parse_args()
        a2u = UMR2AMR(args.infile, args.outfile, args.first, args.last, args.filterid)
